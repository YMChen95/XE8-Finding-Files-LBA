//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
unsigned char* buffer_temp;

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DriveComboBox1Change(TObject *Sender)
{
	this->DirectoryListBox1->Drive=this->DriveComboBox1->Drive;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DirectoryListBox1Change(TObject *Sender)
{
	this->FileListBox1->Directory=this->DirectoryListBox1->Directory;

}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button1Click(TObject *Sender)
{

	int numOfSlash =0;
	TCHAR StrDrive=this->DriveComboBox1->Drive;
	AnsiString StrDirectory = this->DirectoryListBox1 ->Directory  ;
	char ListDirectory[128];
	char fileName[128][128]={""}; //指定分隔后子字符串存储的位置，这里定义二维字符串数组

	strcpy(ListDirectory, StrDirectory.c_str());
	numOfSlash = calc_slash(ListDirectory,'\\');

	const char * split = "\\";
	char * p;
	int i=0;
	p = strtok (ListDirectory,split);
	while(p!=NULL) {
		strcpy(fileName[i], p);
		p = strtok(NULL,split);
		i+=1;
	}


	//TODO: 计算\的个数(完成),分割文件名（完成），for loop 循环


	//int *file_order = new int[numOfSlash+1];

	int offset_temp = 0;
	fileHandle=OpenDeviceHANDLE(StrDrive);
	buffer_temp = new char [512];
	Rdsec_SPTI(fileHandle,offset_temp,buffer_temp,1);

	//TODO 判断MBR,GPT -> 跳转
	//TODO 判断MFT,索引项 -> 跳转
	//TODO

	if(StrToInt(buffer_temp[454])+256*StrToInt(buffer_temp[455])!=0)
		offset_temp = StrToInt(buffer_temp[454])+256*StrToInt(buffer_temp[455]);
	else
		offset_temp=0;

	Edit1->Text = StrDirectory;
	Edit2->Text = offset_temp;
}
//---------------------------------------------------------------------------
HANDLE TForm1::OpenDeviceHANDLE(TCHAR cDriveLetter){

	LPTSTR szVolumeFormat = TEXT("\\\\.\\%c:");
	LPTSTR szRootFormat = TEXT("%c:\\");
    LPTSTR szErrorFormat = TEXT("Error %d: %s\n");
    DWORD accessMode = 0, shareMode = 0;
	UCHAR string[25];
	CHAR printftemp[100];
	shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;  // default
    accessMode = GENERIC_WRITE | GENERIC_READ;       // default
	HANDLE hVolume;
    UINT uDriveType;
    TCHAR szVolumeName[8];
    TCHAR szRootName[5];
    wsprintf(szRootName,szRootFormat,cDriveLetter);

	   wsprintf(szVolumeName,szVolumeFormat,cDriveLetter);
 //   strcpy(string,"\\\\.\\I:");
    hVolume = CreateFile(szVolumeName,
                           accessMode,
                            shareMode,
                                 NULL,
						OPEN_EXISTING,
                                    0,
                                NULL);
         return hVolume;
}

/******************************************************************
        Fucntion Name: Rdsec()
		Command Code:
		Description:
******************************************************************/
BOOL TForm1::Rdsec_SPTI(HANDLE DeviceHandle,int LBA,unsigned char* wbuf,int Sec_Count){
	  BOOL status = 0;
	  SCSI_PASS_THROUGH_WITH_BUFFERS sptwb;
	  SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER sptdwb;
      UCHAR string[25];
      ULONG length = 0,
      returned = 0;
 ZeroMemory(&sptdwb, sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER));
    sptdwb.sptd.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    sptdwb.sptd.PathId = 0;
    sptdwb.sptd.TargetId = 1;
    sptdwb.sptd.Lun = 0;
    sptdwb.sptd.CdbLength = CDB10GENERIC_LENGTH;
    sptdwb.sptd.DataIn = SCSI_IOCTL_DATA_IN;
    sptdwb.sptd.SenseInfoLength = 24;
    sptdwb.sptd.DataTransferLength = (Sec_Count*512);//sectorSize;
    sptdwb.sptd.TimeOutValue = 2;
	sptdwb.sptd.DataBuffer = wbuf;
    sptdwb.sptd.SenseInfoOffset =
       offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf);
    sptdwb.sptd.Cdb[0] =0x28;//operation Code
    sptdwb.sptd.Cdb[1] =0x00;
    sptdwb.sptd.Cdb[2]=(UCHAR)(LBA >> 24);   // Logical Block Address [MSB->LSB]
    sptdwb.sptd.Cdb[3]=(UCHAR)(LBA >> 16);
    sptdwb.sptd.Cdb[4]=(UCHAR)(LBA >> 8); //
    sptdwb.sptd.Cdb[5]=(UCHAR)(LBA);   //
    sptdwb.sptd.Cdb[6]=00;     //Reserved
    sptdwb.sptd.Cdb[7]=0x00;    // Sector Count
    sptdwb.sptd.Cdb[8]=Sec_Count;    // Sector Count
    length = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER);
    status = DeviceIoControl(DeviceHandle,
							 IOCTL_SCSI_PASS_THROUGH_DIRECT,
                             &sptdwb,
							 length,
							 &sptdwb,
                             length,
                             &returned,
                             FALSE);
        return TRUE;
}

int TForm1::calc_slash(const char *p, const char chr)
{
	int count = 0;
	while(*p)
	{
		if(*p == chr)//解引用取出字符与chr比较，指针本身改变
			++count;
		++p;//使用指针指向每个字符所在的内存位地址
	}
	return count;
}



