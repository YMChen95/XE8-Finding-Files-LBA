//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
unsigned char* buffer_temp;

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DriveComboBox1Change(TObject *Sender)
{
	this->DirectoryListBox1->Drive=this->DriveComboBox1->Drive;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DirectoryListBox1Change(TObject *Sender)
{
	this->FileListBox1->Directory=this->DirectoryListBox1->Directory;

}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button1Click(TObject *Sender)
{
	Edit1->Clear();
	Edit2->Clear();
	Edit3->Clear();
	//TODO: 计算\的个数(完成),分割文件名（完成）
	int numOfSlash =0;
	TCHAR StrDrive=this->DriveComboBox1->Drive;
	AnsiString StrDirectory = this->DirectoryListBox1 ->Directory  ;
	char ListDirectory[20];
	char fileName[20][20]={""}; //指定分隔后子字符串存储的位置，这里定义二维字符串数组

	strcpy(ListDirectory, StrDirectory.c_str());
	numOfSlash = calc_slash(ListDirectory,'\\');

	const char * split = "\\";
	char * p;
	int file_pos=0;
	p = strtok (ListDirectory,split);
	while(p!=NULL) {
		strcpy(fileName[file_pos], p);
		p = strtok(NULL,split);
		file_pos+=1;
	}
	Edit1->Text = StrDirectory;

	//TODO 1.跳转$boot区，提取指定位置值，转换10进制（完成）
	//TODO 2..判断MBR,GPT ->跳转至MFT$0->MFT$5号(完成）
	//TODO 3.提取指定位置信息（A0属性,runlist）(完成)
	//TODO 4.loop
	//TODO 5.判断MFT,索引项 -> 跳转
	//TODO 6.

	int offset_temp = 0;
	int phy_to_logi=0; //physical, logical sector 偏移

	fileHandle=OpenDeviceHANDLE(StrDrive);
	buffer_temp = new char [4096];
	Rdsec_SPTI(fileHandle,offset_temp,buffer_temp,1);
	//$boot区
	unsigned char* jumpI_range = GetRange(buffer_temp,454,2);
	phy_to_logi= HextoDec(jumpI_range,2);
	offset_temp+= phy_to_logi;
	memset(buffer_temp,0,sizeof(buffer_temp));
	memset(jumpI_range,0,sizeof(jumpI_range));

	if(file_pos==1){
		Edit2->Text = offset_temp;
		Edit3->Text = "0";
	}

	//跳转$MFT 0号
	Rdsec_SPTI(fileHandle,offset_temp,buffer_temp,1);
	jumpI_range = GetRange(buffer_temp,48,8);//取MFT$0起始簇号
	offset_temp = 8*HextoDec(jumpI_range,8)+phy_to_logi+5*2; //直接加5个LBA到5号
	memset(buffer_temp,0,sizeof(buffer_temp));
	memset(jumpI_range,0,sizeof(jumpI_range));
	Rdsec_SPTI(fileHandle,offset_temp,buffer_temp,1);//跳转到$MFT5号
	//找A0 runlist属性
	for (int i = 55; i < 256; i++) {
		 jumpI_range = GetRange(buffer_temp,i*4,4);
		 if(HextoDec(jumpI_range,4)==0){
			memset(jumpI_range,0,sizeof(jumpI_range));
			jumpI_range = GetRange(buffer_temp,(i+1)*4,4);
			if(HextoDec(jumpI_range,4)==160){
				memset(jumpI_range,0,sizeof(jumpI_range));
				jumpI_range = GetRange(buffer_temp,(i+1)*4+32,1);
				int RunList_offset = HextoDec(jumpI_range,1);
				memset(jumpI_range,0,sizeof(jumpI_range));
				jumpI_range = GetRange(buffer_temp,(i+1)*4+RunList_offset,1);
				//Edit3->Text = "find";
				break;
			}
			else{
				memset(jumpI_range,0,sizeof(jumpI_range));
 				continue;
			}
		 }
		 else{
			continue;
		 }
	}

	int fristpart = jumpI_range[0] >> 4;
	int secondpart = jumpI_range[0]-firstpart*16
	Edit2->Text =fristpart;
    Edit3->Text = secondpart;
	//Edit3->Text =;

	/*
	Application->NormalizeTopMosts();
	#ifdef _DELPHI_STRING_UNICODE
	Application->MessageBox(L"This should be on top.", L"Look", MB_OKCANCEL);
	#else
	Application->MessageBox("This should be on top.", "Look", MB_OKCANCEL);
	#endif
	Application->RestoreTopMosts();
	*/

}
//---------------------------------------------------------------------------
HANDLE TForm1::OpenDeviceHANDLE(TCHAR cDriveLetter){

	LPTSTR szVolumeFormat = TEXT("\\\\.\\%c:");
	LPTSTR szRootFormat = TEXT("%c:\\");
    LPTSTR szErrorFormat = TEXT("Error %d: %s\n");
    DWORD accessMode = 0, shareMode = 0;
	UCHAR string[25];
	CHAR printftemp[100];
	shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;  // default
    accessMode = GENERIC_WRITE | GENERIC_READ;       // default
	HANDLE hVolume;
    UINT uDriveType;
    TCHAR szVolumeName[8];
    TCHAR szRootName[5];
    wsprintf(szRootName,szRootFormat,cDriveLetter);

	   wsprintf(szVolumeName,szVolumeFormat,cDriveLetter);
 //   strcpy(string,"\\\\.\\I:");
    hVolume = CreateFile(szVolumeName,
                           accessMode,
                            shareMode,
                                 NULL,
						OPEN_EXISTING,
                                    0,
                                NULL);
         return hVolume;
}

/******************************************************************
        Fucntion Name: Rdsec()
		Command Code:
		Description:
******************************************************************/
BOOL TForm1::Rdsec_SPTI(HANDLE DeviceHandle,int LBA,unsigned char* wbuf,int Sec_Count){
	  BOOL status = 0;
	  SCSI_PASS_THROUGH_WITH_BUFFERS sptwb;
	  SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER sptdwb;
      UCHAR string[25];
      ULONG length = 0,
      returned = 0;
 ZeroMemory(&sptdwb, sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER));
    sptdwb.sptd.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    sptdwb.sptd.PathId = 0;
    sptdwb.sptd.TargetId = 1;
    sptdwb.sptd.Lun = 0;
    sptdwb.sptd.CdbLength = CDB10GENERIC_LENGTH;
    sptdwb.sptd.DataIn = SCSI_IOCTL_DATA_IN;
    sptdwb.sptd.SenseInfoLength = 24;
    sptdwb.sptd.DataTransferLength = (Sec_Count*512);//sectorSize;
    sptdwb.sptd.TimeOutValue = 2;
	sptdwb.sptd.DataBuffer = wbuf;
    sptdwb.sptd.SenseInfoOffset =
       offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf);
    sptdwb.sptd.Cdb[0] =0x28;//operation Code
    sptdwb.sptd.Cdb[1] =0x00;
    sptdwb.sptd.Cdb[2]=(UCHAR)(LBA >> 24);   // Logical Block Address [MSB->LSB]
    sptdwb.sptd.Cdb[3]=(UCHAR)(LBA >> 16);
    sptdwb.sptd.Cdb[4]=(UCHAR)(LBA >> 8); //
    sptdwb.sptd.Cdb[5]=(UCHAR)(LBA);   //
    sptdwb.sptd.Cdb[6]=00;     //Reserved
    sptdwb.sptd.Cdb[7]=0x00;    // Sector Count
    sptdwb.sptd.Cdb[8]=Sec_Count;    // Sector Count
    length = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER);
    status = DeviceIoControl(DeviceHandle,
							 IOCTL_SCSI_PASS_THROUGH_DIRECT,
                             &sptdwb,
							 length,
							 &sptdwb,
                             length,
                             &returned,
                             FALSE);
        return TRUE;
}

int TForm1::calc_slash(const char *p, const char chr)
{
	int count = 0;
	while(*p)
	{
		if(*p == chr)//解引用取出字符与chr比较，指针本身改变
			++count;
		++p;//使用指针指向每个字符所在的内存位地址
	}
	return count;
}

unsigned char* TForm1::GetRange(unsigned char* p, int a, int b)
{
	unsigned char*temp_p = new unsigned char[b+1];

	for (int i = 0; i < b; i++) {
		temp_p[i]=p[a+b-1-i];
	}
	return temp_p;
}


unsigned long TForm1::HextoDec(const unsigned char *hex, int length)
{
	int i;
	unsigned long rslt = 0;
	for (i = 0; i < length; i++)
	{
		rslt += (unsigned long)(hex[i]) << (8 * (length - 1 - i));
	}
	return rslt;
}

